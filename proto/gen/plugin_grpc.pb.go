// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.17.3
// source: plugin.proto

package proto

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// ExecSessionServiceClient is the client API for ExecSessionService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ExecSessionServiceClient interface {
	Output(ctx context.Context, in *ExecSession_OutputRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Input(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (ExecSessionService_InputClient, error)
}

type execSessionServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewExecSessionServiceClient(cc grpc.ClientConnInterface) ExecSessionServiceClient {
	return &execSessionServiceClient{cc}
}

func (c *execSessionServiceClient) Output(ctx context.Context, in *ExecSession_OutputRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/hashicorp.waypoint.sdk.ExecSessionService/Output", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *execSessionServiceClient) Input(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (ExecSessionService_InputClient, error) {
	stream, err := c.cc.NewStream(ctx, &ExecSessionService_ServiceDesc.Streams[0], "/hashicorp.waypoint.sdk.ExecSessionService/Input", opts...)
	if err != nil {
		return nil, err
	}
	x := &execSessionServiceInputClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ExecSessionService_InputClient interface {
	Recv() (*ExecSession_InputRequest, error)
	grpc.ClientStream
}

type execSessionServiceInputClient struct {
	grpc.ClientStream
}

func (x *execSessionServiceInputClient) Recv() (*ExecSession_InputRequest, error) {
	m := new(ExecSession_InputRequest)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// ExecSessionServiceServer is the server API for ExecSessionService service.
// All implementations must embed UnimplementedExecSessionServiceServer
// for forward compatibility
type ExecSessionServiceServer interface {
	Output(context.Context, *ExecSession_OutputRequest) (*emptypb.Empty, error)
	Input(*emptypb.Empty, ExecSessionService_InputServer) error
	mustEmbedUnimplementedExecSessionServiceServer()
}

// UnimplementedExecSessionServiceServer must be embedded to have forward compatible implementations.
type UnimplementedExecSessionServiceServer struct {
}

func (UnimplementedExecSessionServiceServer) Output(context.Context, *ExecSession_OutputRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Output not implemented")
}
func (UnimplementedExecSessionServiceServer) Input(*emptypb.Empty, ExecSessionService_InputServer) error {
	return status.Errorf(codes.Unimplemented, "method Input not implemented")
}
func (UnimplementedExecSessionServiceServer) mustEmbedUnimplementedExecSessionServiceServer() {}

// UnsafeExecSessionServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ExecSessionServiceServer will
// result in compilation errors.
type UnsafeExecSessionServiceServer interface {
	mustEmbedUnimplementedExecSessionServiceServer()
}

func RegisterExecSessionServiceServer(s grpc.ServiceRegistrar, srv ExecSessionServiceServer) {
	s.RegisterService(&ExecSessionService_ServiceDesc, srv)
}

func _ExecSessionService_Output_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExecSession_OutputRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExecSessionServiceServer).Output(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.waypoint.sdk.ExecSessionService/Output",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExecSessionServiceServer).Output(ctx, req.(*ExecSession_OutputRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExecSessionService_Input_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(emptypb.Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ExecSessionServiceServer).Input(m, &execSessionServiceInputServer{stream})
}

type ExecSessionService_InputServer interface {
	Send(*ExecSession_InputRequest) error
	grpc.ServerStream
}

type execSessionServiceInputServer struct {
	grpc.ServerStream
}

func (x *execSessionServiceInputServer) Send(m *ExecSession_InputRequest) error {
	return x.ServerStream.SendMsg(m)
}

// ExecSessionService_ServiceDesc is the grpc.ServiceDesc for ExecSessionService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ExecSessionService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "hashicorp.waypoint.sdk.ExecSessionService",
	HandlerType: (*ExecSessionServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Output",
			Handler:    _ExecSessionService_Output_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Input",
			Handler:       _ExecSessionService_Input_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "plugin.proto",
}

// LogViewerClient is the client API for LogViewer service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type LogViewerClient interface {
	NextLogBatch(ctx context.Context, opts ...grpc.CallOption) (LogViewer_NextLogBatchClient, error)
}

type logViewerClient struct {
	cc grpc.ClientConnInterface
}

func NewLogViewerClient(cc grpc.ClientConnInterface) LogViewerClient {
	return &logViewerClient{cc}
}

func (c *logViewerClient) NextLogBatch(ctx context.Context, opts ...grpc.CallOption) (LogViewer_NextLogBatchClient, error) {
	stream, err := c.cc.NewStream(ctx, &LogViewer_ServiceDesc.Streams[0], "/hashicorp.waypoint.sdk.LogViewer/NextLogBatch", opts...)
	if err != nil {
		return nil, err
	}
	x := &logViewerNextLogBatchClient{stream}
	return x, nil
}

type LogViewer_NextLogBatchClient interface {
	Send(*Logs_NextBatchResp) error
	CloseAndRecv() (*emptypb.Empty, error)
	grpc.ClientStream
}

type logViewerNextLogBatchClient struct {
	grpc.ClientStream
}

func (x *logViewerNextLogBatchClient) Send(m *Logs_NextBatchResp) error {
	return x.ClientStream.SendMsg(m)
}

func (x *logViewerNextLogBatchClient) CloseAndRecv() (*emptypb.Empty, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(emptypb.Empty)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// LogViewerServer is the server API for LogViewer service.
// All implementations must embed UnimplementedLogViewerServer
// for forward compatibility
type LogViewerServer interface {
	NextLogBatch(LogViewer_NextLogBatchServer) error
	mustEmbedUnimplementedLogViewerServer()
}

// UnimplementedLogViewerServer must be embedded to have forward compatible implementations.
type UnimplementedLogViewerServer struct {
}

func (UnimplementedLogViewerServer) NextLogBatch(LogViewer_NextLogBatchServer) error {
	return status.Errorf(codes.Unimplemented, "method NextLogBatch not implemented")
}
func (UnimplementedLogViewerServer) mustEmbedUnimplementedLogViewerServer() {}

// UnsafeLogViewerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to LogViewerServer will
// result in compilation errors.
type UnsafeLogViewerServer interface {
	mustEmbedUnimplementedLogViewerServer()
}

func RegisterLogViewerServer(s grpc.ServiceRegistrar, srv LogViewerServer) {
	s.RegisterService(&LogViewer_ServiceDesc, srv)
}

func _LogViewer_NextLogBatch_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(LogViewerServer).NextLogBatch(&logViewerNextLogBatchServer{stream})
}

type LogViewer_NextLogBatchServer interface {
	SendAndClose(*emptypb.Empty) error
	Recv() (*Logs_NextBatchResp, error)
	grpc.ServerStream
}

type logViewerNextLogBatchServer struct {
	grpc.ServerStream
}

func (x *logViewerNextLogBatchServer) SendAndClose(m *emptypb.Empty) error {
	return x.ServerStream.SendMsg(m)
}

func (x *logViewerNextLogBatchServer) Recv() (*Logs_NextBatchResp, error) {
	m := new(Logs_NextBatchResp)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// LogViewer_ServiceDesc is the grpc.ServiceDesc for LogViewer service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var LogViewer_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "hashicorp.waypoint.sdk.LogViewer",
	HandlerType: (*LogViewerServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "NextLogBatch",
			Handler:       _LogViewer_NextLogBatch_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "plugin.proto",
}

// TerminalUIServiceClient is the client API for TerminalUIService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TerminalUIServiceClient interface {
	Output(ctx context.Context, in *TerminalUI_OutputRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Events(ctx context.Context, opts ...grpc.CallOption) (TerminalUIService_EventsClient, error)
	IsInteractive(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*TerminalUI_IsInteractiveResponse, error)
}

type terminalUIServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewTerminalUIServiceClient(cc grpc.ClientConnInterface) TerminalUIServiceClient {
	return &terminalUIServiceClient{cc}
}

func (c *terminalUIServiceClient) Output(ctx context.Context, in *TerminalUI_OutputRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/hashicorp.waypoint.sdk.TerminalUIService/Output", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *terminalUIServiceClient) Events(ctx context.Context, opts ...grpc.CallOption) (TerminalUIService_EventsClient, error) {
	stream, err := c.cc.NewStream(ctx, &TerminalUIService_ServiceDesc.Streams[0], "/hashicorp.waypoint.sdk.TerminalUIService/Events", opts...)
	if err != nil {
		return nil, err
	}
	x := &terminalUIServiceEventsClient{stream}
	return x, nil
}

type TerminalUIService_EventsClient interface {
	Send(*TerminalUI_Event) error
	Recv() (*TerminalUI_Response, error)
	grpc.ClientStream
}

type terminalUIServiceEventsClient struct {
	grpc.ClientStream
}

func (x *terminalUIServiceEventsClient) Send(m *TerminalUI_Event) error {
	return x.ClientStream.SendMsg(m)
}

func (x *terminalUIServiceEventsClient) Recv() (*TerminalUI_Response, error) {
	m := new(TerminalUI_Response)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *terminalUIServiceClient) IsInteractive(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*TerminalUI_IsInteractiveResponse, error) {
	out := new(TerminalUI_IsInteractiveResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.waypoint.sdk.TerminalUIService/IsInteractive", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TerminalUIServiceServer is the server API for TerminalUIService service.
// All implementations must embed UnimplementedTerminalUIServiceServer
// for forward compatibility
type TerminalUIServiceServer interface {
	Output(context.Context, *TerminalUI_OutputRequest) (*emptypb.Empty, error)
	Events(TerminalUIService_EventsServer) error
	IsInteractive(context.Context, *emptypb.Empty) (*TerminalUI_IsInteractiveResponse, error)
	mustEmbedUnimplementedTerminalUIServiceServer()
}

// UnimplementedTerminalUIServiceServer must be embedded to have forward compatible implementations.
type UnimplementedTerminalUIServiceServer struct {
}

func (UnimplementedTerminalUIServiceServer) Output(context.Context, *TerminalUI_OutputRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Output not implemented")
}
func (UnimplementedTerminalUIServiceServer) Events(TerminalUIService_EventsServer) error {
	return status.Errorf(codes.Unimplemented, "method Events not implemented")
}
func (UnimplementedTerminalUIServiceServer) IsInteractive(context.Context, *emptypb.Empty) (*TerminalUI_IsInteractiveResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsInteractive not implemented")
}
func (UnimplementedTerminalUIServiceServer) mustEmbedUnimplementedTerminalUIServiceServer() {}

// UnsafeTerminalUIServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TerminalUIServiceServer will
// result in compilation errors.
type UnsafeTerminalUIServiceServer interface {
	mustEmbedUnimplementedTerminalUIServiceServer()
}

func RegisterTerminalUIServiceServer(s grpc.ServiceRegistrar, srv TerminalUIServiceServer) {
	s.RegisterService(&TerminalUIService_ServiceDesc, srv)
}

func _TerminalUIService_Output_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TerminalUI_OutputRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TerminalUIServiceServer).Output(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.waypoint.sdk.TerminalUIService/Output",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TerminalUIServiceServer).Output(ctx, req.(*TerminalUI_OutputRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TerminalUIService_Events_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(TerminalUIServiceServer).Events(&terminalUIServiceEventsServer{stream})
}

type TerminalUIService_EventsServer interface {
	Send(*TerminalUI_Response) error
	Recv() (*TerminalUI_Event, error)
	grpc.ServerStream
}

type terminalUIServiceEventsServer struct {
	grpc.ServerStream
}

func (x *terminalUIServiceEventsServer) Send(m *TerminalUI_Response) error {
	return x.ServerStream.SendMsg(m)
}

func (x *terminalUIServiceEventsServer) Recv() (*TerminalUI_Event, error) {
	m := new(TerminalUI_Event)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _TerminalUIService_IsInteractive_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TerminalUIServiceServer).IsInteractive(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.waypoint.sdk.TerminalUIService/IsInteractive",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TerminalUIServiceServer).IsInteractive(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// TerminalUIService_ServiceDesc is the grpc.ServiceDesc for TerminalUIService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TerminalUIService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "hashicorp.waypoint.sdk.TerminalUIService",
	HandlerType: (*TerminalUIServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Output",
			Handler:    _TerminalUIService_Output_Handler,
		},
		{
			MethodName: "IsInteractive",
			Handler:    _TerminalUIService_IsInteractive_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Events",
			Handler:       _TerminalUIService_Events_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "plugin.proto",
}

// MapperClient is the client API for Mapper service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MapperClient interface {
	// ListMappers returns the list of mappers that this plugin supports.
	ListMappers(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Map_ListResponse, error)
	// Map executes a mapper.
	Map(ctx context.Context, in *Map_Request, opts ...grpc.CallOption) (*Map_Response, error)
}

type mapperClient struct {
	cc grpc.ClientConnInterface
}

func NewMapperClient(cc grpc.ClientConnInterface) MapperClient {
	return &mapperClient{cc}
}

func (c *mapperClient) ListMappers(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Map_ListResponse, error) {
	out := new(Map_ListResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.waypoint.sdk.Mapper/ListMappers", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mapperClient) Map(ctx context.Context, in *Map_Request, opts ...grpc.CallOption) (*Map_Response, error) {
	out := new(Map_Response)
	err := c.cc.Invoke(ctx, "/hashicorp.waypoint.sdk.Mapper/Map", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MapperServer is the server API for Mapper service.
// All implementations must embed UnimplementedMapperServer
// for forward compatibility
type MapperServer interface {
	// ListMappers returns the list of mappers that this plugin supports.
	ListMappers(context.Context, *emptypb.Empty) (*Map_ListResponse, error)
	// Map executes a mapper.
	Map(context.Context, *Map_Request) (*Map_Response, error)
	mustEmbedUnimplementedMapperServer()
}

// UnimplementedMapperServer must be embedded to have forward compatible implementations.
type UnimplementedMapperServer struct {
}

func (UnimplementedMapperServer) ListMappers(context.Context, *emptypb.Empty) (*Map_ListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListMappers not implemented")
}
func (UnimplementedMapperServer) Map(context.Context, *Map_Request) (*Map_Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Map not implemented")
}
func (UnimplementedMapperServer) mustEmbedUnimplementedMapperServer() {}

// UnsafeMapperServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MapperServer will
// result in compilation errors.
type UnsafeMapperServer interface {
	mustEmbedUnimplementedMapperServer()
}

func RegisterMapperServer(s grpc.ServiceRegistrar, srv MapperServer) {
	s.RegisterService(&Mapper_ServiceDesc, srv)
}

func _Mapper_ListMappers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MapperServer).ListMappers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.waypoint.sdk.Mapper/ListMappers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MapperServer).ListMappers(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mapper_Map_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Map_Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MapperServer).Map(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.waypoint.sdk.Mapper/Map",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MapperServer).Map(ctx, req.(*Map_Request))
	}
	return interceptor(ctx, in, info, handler)
}

// Mapper_ServiceDesc is the grpc.ServiceDesc for Mapper service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Mapper_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "hashicorp.waypoint.sdk.Mapper",
	HandlerType: (*MapperServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListMappers",
			Handler:    _Mapper_ListMappers_Handler,
		},
		{
			MethodName: "Map",
			Handler:    _Mapper_Map_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "plugin.proto",
}

// BuilderClient is the client API for Builder service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type BuilderClient interface {
	IsAuthenticator(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ImplementsResp, error)
	Auth(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Auth_AuthResponse, error)
	AuthSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	ValidateAuth(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*emptypb.Empty, error)
	ValidateAuthSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	ConfigStruct(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Config_StructResp, error)
	Configure(ctx context.Context, in *Config_ConfigureRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Documentation(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Config_Documentation, error)
	BuildSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	Build(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Build_Resp, error)
	BuildODR(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Build_Resp, error)
	BuildSpecODR(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
}

type builderClient struct {
	cc grpc.ClientConnInterface
}

func NewBuilderClient(cc grpc.ClientConnInterface) BuilderClient {
	return &builderClient{cc}
}

func (c *builderClient) IsAuthenticator(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ImplementsResp, error) {
	out := new(ImplementsResp)
	err := c.cc.Invoke(ctx, "/hashicorp.waypoint.sdk.Builder/IsAuthenticator", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *builderClient) Auth(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Auth_AuthResponse, error) {
	out := new(Auth_AuthResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.waypoint.sdk.Builder/Auth", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *builderClient) AuthSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, "/hashicorp.waypoint.sdk.Builder/AuthSpec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *builderClient) ValidateAuth(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/hashicorp.waypoint.sdk.Builder/ValidateAuth", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *builderClient) ValidateAuthSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, "/hashicorp.waypoint.sdk.Builder/ValidateAuthSpec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *builderClient) ConfigStruct(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Config_StructResp, error) {
	out := new(Config_StructResp)
	err := c.cc.Invoke(ctx, "/hashicorp.waypoint.sdk.Builder/ConfigStruct", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *builderClient) Configure(ctx context.Context, in *Config_ConfigureRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/hashicorp.waypoint.sdk.Builder/Configure", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *builderClient) Documentation(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Config_Documentation, error) {
	out := new(Config_Documentation)
	err := c.cc.Invoke(ctx, "/hashicorp.waypoint.sdk.Builder/Documentation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *builderClient) BuildSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, "/hashicorp.waypoint.sdk.Builder/BuildSpec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *builderClient) Build(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Build_Resp, error) {
	out := new(Build_Resp)
	err := c.cc.Invoke(ctx, "/hashicorp.waypoint.sdk.Builder/Build", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *builderClient) BuildODR(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Build_Resp, error) {
	out := new(Build_Resp)
	err := c.cc.Invoke(ctx, "/hashicorp.waypoint.sdk.Builder/BuildODR", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *builderClient) BuildSpecODR(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, "/hashicorp.waypoint.sdk.Builder/BuildSpecODR", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BuilderServer is the server API for Builder service.
// All implementations must embed UnimplementedBuilderServer
// for forward compatibility
type BuilderServer interface {
	IsAuthenticator(context.Context, *emptypb.Empty) (*ImplementsResp, error)
	Auth(context.Context, *FuncSpec_Args) (*Auth_AuthResponse, error)
	AuthSpec(context.Context, *emptypb.Empty) (*FuncSpec, error)
	ValidateAuth(context.Context, *FuncSpec_Args) (*emptypb.Empty, error)
	ValidateAuthSpec(context.Context, *emptypb.Empty) (*FuncSpec, error)
	ConfigStruct(context.Context, *emptypb.Empty) (*Config_StructResp, error)
	Configure(context.Context, *Config_ConfigureRequest) (*emptypb.Empty, error)
	Documentation(context.Context, *emptypb.Empty) (*Config_Documentation, error)
	BuildSpec(context.Context, *emptypb.Empty) (*FuncSpec, error)
	Build(context.Context, *FuncSpec_Args) (*Build_Resp, error)
	BuildODR(context.Context, *FuncSpec_Args) (*Build_Resp, error)
	BuildSpecODR(context.Context, *emptypb.Empty) (*FuncSpec, error)
	mustEmbedUnimplementedBuilderServer()
}

// UnimplementedBuilderServer must be embedded to have forward compatible implementations.
type UnimplementedBuilderServer struct {
}

func (UnimplementedBuilderServer) IsAuthenticator(context.Context, *emptypb.Empty) (*ImplementsResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsAuthenticator not implemented")
}
func (UnimplementedBuilderServer) Auth(context.Context, *FuncSpec_Args) (*Auth_AuthResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Auth not implemented")
}
func (UnimplementedBuilderServer) AuthSpec(context.Context, *emptypb.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AuthSpec not implemented")
}
func (UnimplementedBuilderServer) ValidateAuth(context.Context, *FuncSpec_Args) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ValidateAuth not implemented")
}
func (UnimplementedBuilderServer) ValidateAuthSpec(context.Context, *emptypb.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ValidateAuthSpec not implemented")
}
func (UnimplementedBuilderServer) ConfigStruct(context.Context, *emptypb.Empty) (*Config_StructResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfigStruct not implemented")
}
func (UnimplementedBuilderServer) Configure(context.Context, *Config_ConfigureRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Configure not implemented")
}
func (UnimplementedBuilderServer) Documentation(context.Context, *emptypb.Empty) (*Config_Documentation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Documentation not implemented")
}
func (UnimplementedBuilderServer) BuildSpec(context.Context, *emptypb.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BuildSpec not implemented")
}
func (UnimplementedBuilderServer) Build(context.Context, *FuncSpec_Args) (*Build_Resp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Build not implemented")
}
func (UnimplementedBuilderServer) BuildODR(context.Context, *FuncSpec_Args) (*Build_Resp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BuildODR not implemented")
}
func (UnimplementedBuilderServer) BuildSpecODR(context.Context, *emptypb.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BuildSpecODR not implemented")
}
func (UnimplementedBuilderServer) mustEmbedUnimplementedBuilderServer() {}

// UnsafeBuilderServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to BuilderServer will
// result in compilation errors.
type UnsafeBuilderServer interface {
	mustEmbedUnimplementedBuilderServer()
}

func RegisterBuilderServer(s grpc.ServiceRegistrar, srv BuilderServer) {
	s.RegisterService(&Builder_ServiceDesc, srv)
}

func _Builder_IsAuthenticator_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BuilderServer).IsAuthenticator(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.waypoint.sdk.Builder/IsAuthenticator",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BuilderServer).IsAuthenticator(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Builder_Auth_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BuilderServer).Auth(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.waypoint.sdk.Builder/Auth",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BuilderServer).Auth(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

func _Builder_AuthSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BuilderServer).AuthSpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.waypoint.sdk.Builder/AuthSpec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BuilderServer).AuthSpec(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Builder_ValidateAuth_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BuilderServer).ValidateAuth(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.waypoint.sdk.Builder/ValidateAuth",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BuilderServer).ValidateAuth(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

func _Builder_ValidateAuthSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BuilderServer).ValidateAuthSpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.waypoint.sdk.Builder/ValidateAuthSpec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BuilderServer).ValidateAuthSpec(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Builder_ConfigStruct_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BuilderServer).ConfigStruct(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.waypoint.sdk.Builder/ConfigStruct",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BuilderServer).ConfigStruct(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Builder_Configure_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Config_ConfigureRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BuilderServer).Configure(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.waypoint.sdk.Builder/Configure",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BuilderServer).Configure(ctx, req.(*Config_ConfigureRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Builder_Documentation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BuilderServer).Documentation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.waypoint.sdk.Builder/Documentation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BuilderServer).Documentation(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Builder_BuildSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BuilderServer).BuildSpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.waypoint.sdk.Builder/BuildSpec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BuilderServer).BuildSpec(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Builder_Build_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BuilderServer).Build(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.waypoint.sdk.Builder/Build",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BuilderServer).Build(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

func _Builder_BuildODR_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BuilderServer).BuildODR(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.waypoint.sdk.Builder/BuildODR",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BuilderServer).BuildODR(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

func _Builder_BuildSpecODR_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BuilderServer).BuildSpecODR(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.waypoint.sdk.Builder/BuildSpecODR",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BuilderServer).BuildSpecODR(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// Builder_ServiceDesc is the grpc.ServiceDesc for Builder service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Builder_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "hashicorp.waypoint.sdk.Builder",
	HandlerType: (*BuilderServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "IsAuthenticator",
			Handler:    _Builder_IsAuthenticator_Handler,
		},
		{
			MethodName: "Auth",
			Handler:    _Builder_Auth_Handler,
		},
		{
			MethodName: "AuthSpec",
			Handler:    _Builder_AuthSpec_Handler,
		},
		{
			MethodName: "ValidateAuth",
			Handler:    _Builder_ValidateAuth_Handler,
		},
		{
			MethodName: "ValidateAuthSpec",
			Handler:    _Builder_ValidateAuthSpec_Handler,
		},
		{
			MethodName: "ConfigStruct",
			Handler:    _Builder_ConfigStruct_Handler,
		},
		{
			MethodName: "Configure",
			Handler:    _Builder_Configure_Handler,
		},
		{
			MethodName: "Documentation",
			Handler:    _Builder_Documentation_Handler,
		},
		{
			MethodName: "BuildSpec",
			Handler:    _Builder_BuildSpec_Handler,
		},
		{
			MethodName: "Build",
			Handler:    _Builder_Build_Handler,
		},
		{
			MethodName: "BuildODR",
			Handler:    _Builder_BuildODR_Handler,
		},
		{
			MethodName: "BuildSpecODR",
			Handler:    _Builder_BuildSpecODR_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "plugin.proto",
}

// PlatformClient is the client API for Platform service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type PlatformClient interface {
	IsAuthenticator(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ImplementsResp, error)
	Auth(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Auth_AuthResponse, error)
	AuthSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	ValidateAuth(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*emptypb.Empty, error)
	ValidateAuthSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	ConfigStruct(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Config_StructResp, error)
	Configure(ctx context.Context, in *Config_ConfigureRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Documentation(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Config_Documentation, error)
	DeploySpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	Deploy(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Deploy_Resp, error)
	// component.PlatformReleaser optional implementation.
	DefaultReleaserSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	DefaultReleaser(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*DefaultReleaser_Resp, error)
	// component.Destroyer optional implementation
	IsDestroyer(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ImplementsResp, error)
	DestroySpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	Destroy(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Destroy_Resp, error)
	// component.WorkspaceDestroyer optional implementation
	IsWorkspaceDestroyer(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ImplementsResp, error)
	DestroyWorkspaceSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	DestroyWorkspace(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// component.Execer optional implementation
	IsExecer(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ImplementsResp, error)
	ExecSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	Exec(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*ExecResult, error)
	// component.LogViewer optional implementation
	// IsLogPlatform returns true if this platform also implements LogPlatform.
	IsLogPlatform(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ImplementsResp, error)
	LogsSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	Logs(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// component.Generation optional implementation
	IsGeneration(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ImplementsResp, error)
	GenerationSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	Generation(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Generation_Resp, error)
	// component.Status optional implementation
	IsStatus(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ImplementsResp, error)
	StatusSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	Status(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*StatusReport, error)
}

type platformClient struct {
	cc grpc.ClientConnInterface
}

func NewPlatformClient(cc grpc.ClientConnInterface) PlatformClient {
	return &platformClient{cc}
}

func (c *platformClient) IsAuthenticator(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ImplementsResp, error) {
	out := new(ImplementsResp)
	err := c.cc.Invoke(ctx, "/hashicorp.waypoint.sdk.Platform/IsAuthenticator", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *platformClient) Auth(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Auth_AuthResponse, error) {
	out := new(Auth_AuthResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.waypoint.sdk.Platform/Auth", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *platformClient) AuthSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, "/hashicorp.waypoint.sdk.Platform/AuthSpec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *platformClient) ValidateAuth(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/hashicorp.waypoint.sdk.Platform/ValidateAuth", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *platformClient) ValidateAuthSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, "/hashicorp.waypoint.sdk.Platform/ValidateAuthSpec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *platformClient) ConfigStruct(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Config_StructResp, error) {
	out := new(Config_StructResp)
	err := c.cc.Invoke(ctx, "/hashicorp.waypoint.sdk.Platform/ConfigStruct", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *platformClient) Configure(ctx context.Context, in *Config_ConfigureRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/hashicorp.waypoint.sdk.Platform/Configure", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *platformClient) Documentation(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Config_Documentation, error) {
	out := new(Config_Documentation)
	err := c.cc.Invoke(ctx, "/hashicorp.waypoint.sdk.Platform/Documentation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *platformClient) DeploySpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, "/hashicorp.waypoint.sdk.Platform/DeploySpec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *platformClient) Deploy(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Deploy_Resp, error) {
	out := new(Deploy_Resp)
	err := c.cc.Invoke(ctx, "/hashicorp.waypoint.sdk.Platform/Deploy", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *platformClient) DefaultReleaserSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, "/hashicorp.waypoint.sdk.Platform/DefaultReleaserSpec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *platformClient) DefaultReleaser(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*DefaultReleaser_Resp, error) {
	out := new(DefaultReleaser_Resp)
	err := c.cc.Invoke(ctx, "/hashicorp.waypoint.sdk.Platform/DefaultReleaser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *platformClient) IsDestroyer(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ImplementsResp, error) {
	out := new(ImplementsResp)
	err := c.cc.Invoke(ctx, "/hashicorp.waypoint.sdk.Platform/IsDestroyer", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *platformClient) DestroySpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, "/hashicorp.waypoint.sdk.Platform/DestroySpec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *platformClient) Destroy(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Destroy_Resp, error) {
	out := new(Destroy_Resp)
	err := c.cc.Invoke(ctx, "/hashicorp.waypoint.sdk.Platform/Destroy", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *platformClient) IsWorkspaceDestroyer(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ImplementsResp, error) {
	out := new(ImplementsResp)
	err := c.cc.Invoke(ctx, "/hashicorp.waypoint.sdk.Platform/IsWorkspaceDestroyer", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *platformClient) DestroyWorkspaceSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, "/hashicorp.waypoint.sdk.Platform/DestroyWorkspaceSpec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *platformClient) DestroyWorkspace(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/hashicorp.waypoint.sdk.Platform/DestroyWorkspace", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *platformClient) IsExecer(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ImplementsResp, error) {
	out := new(ImplementsResp)
	err := c.cc.Invoke(ctx, "/hashicorp.waypoint.sdk.Platform/IsExecer", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *platformClient) ExecSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, "/hashicorp.waypoint.sdk.Platform/ExecSpec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *platformClient) Exec(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*ExecResult, error) {
	out := new(ExecResult)
	err := c.cc.Invoke(ctx, "/hashicorp.waypoint.sdk.Platform/Exec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *platformClient) IsLogPlatform(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ImplementsResp, error) {
	out := new(ImplementsResp)
	err := c.cc.Invoke(ctx, "/hashicorp.waypoint.sdk.Platform/IsLogPlatform", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *platformClient) LogsSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, "/hashicorp.waypoint.sdk.Platform/LogsSpec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *platformClient) Logs(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/hashicorp.waypoint.sdk.Platform/Logs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *platformClient) IsGeneration(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ImplementsResp, error) {
	out := new(ImplementsResp)
	err := c.cc.Invoke(ctx, "/hashicorp.waypoint.sdk.Platform/IsGeneration", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *platformClient) GenerationSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, "/hashicorp.waypoint.sdk.Platform/GenerationSpec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *platformClient) Generation(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Generation_Resp, error) {
	out := new(Generation_Resp)
	err := c.cc.Invoke(ctx, "/hashicorp.waypoint.sdk.Platform/Generation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *platformClient) IsStatus(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ImplementsResp, error) {
	out := new(ImplementsResp)
	err := c.cc.Invoke(ctx, "/hashicorp.waypoint.sdk.Platform/IsStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *platformClient) StatusSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, "/hashicorp.waypoint.sdk.Platform/StatusSpec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *platformClient) Status(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*StatusReport, error) {
	out := new(StatusReport)
	err := c.cc.Invoke(ctx, "/hashicorp.waypoint.sdk.Platform/Status", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PlatformServer is the server API for Platform service.
// All implementations must embed UnimplementedPlatformServer
// for forward compatibility
type PlatformServer interface {
	IsAuthenticator(context.Context, *emptypb.Empty) (*ImplementsResp, error)
	Auth(context.Context, *FuncSpec_Args) (*Auth_AuthResponse, error)
	AuthSpec(context.Context, *emptypb.Empty) (*FuncSpec, error)
	ValidateAuth(context.Context, *FuncSpec_Args) (*emptypb.Empty, error)
	ValidateAuthSpec(context.Context, *emptypb.Empty) (*FuncSpec, error)
	ConfigStruct(context.Context, *emptypb.Empty) (*Config_StructResp, error)
	Configure(context.Context, *Config_ConfigureRequest) (*emptypb.Empty, error)
	Documentation(context.Context, *emptypb.Empty) (*Config_Documentation, error)
	DeploySpec(context.Context, *emptypb.Empty) (*FuncSpec, error)
	Deploy(context.Context, *FuncSpec_Args) (*Deploy_Resp, error)
	// component.PlatformReleaser optional implementation.
	DefaultReleaserSpec(context.Context, *emptypb.Empty) (*FuncSpec, error)
	DefaultReleaser(context.Context, *FuncSpec_Args) (*DefaultReleaser_Resp, error)
	// component.Destroyer optional implementation
	IsDestroyer(context.Context, *emptypb.Empty) (*ImplementsResp, error)
	DestroySpec(context.Context, *emptypb.Empty) (*FuncSpec, error)
	Destroy(context.Context, *FuncSpec_Args) (*Destroy_Resp, error)
	// component.WorkspaceDestroyer optional implementation
	IsWorkspaceDestroyer(context.Context, *emptypb.Empty) (*ImplementsResp, error)
	DestroyWorkspaceSpec(context.Context, *emptypb.Empty) (*FuncSpec, error)
	DestroyWorkspace(context.Context, *FuncSpec_Args) (*emptypb.Empty, error)
	// component.Execer optional implementation
	IsExecer(context.Context, *emptypb.Empty) (*ImplementsResp, error)
	ExecSpec(context.Context, *emptypb.Empty) (*FuncSpec, error)
	Exec(context.Context, *FuncSpec_Args) (*ExecResult, error)
	// component.LogViewer optional implementation
	// IsLogPlatform returns true if this platform also implements LogPlatform.
	IsLogPlatform(context.Context, *emptypb.Empty) (*ImplementsResp, error)
	LogsSpec(context.Context, *emptypb.Empty) (*FuncSpec, error)
	Logs(context.Context, *FuncSpec_Args) (*emptypb.Empty, error)
	// component.Generation optional implementation
	IsGeneration(context.Context, *emptypb.Empty) (*ImplementsResp, error)
	GenerationSpec(context.Context, *emptypb.Empty) (*FuncSpec, error)
	Generation(context.Context, *FuncSpec_Args) (*Generation_Resp, error)
	// component.Status optional implementation
	IsStatus(context.Context, *emptypb.Empty) (*ImplementsResp, error)
	StatusSpec(context.Context, *emptypb.Empty) (*FuncSpec, error)
	Status(context.Context, *FuncSpec_Args) (*StatusReport, error)
	mustEmbedUnimplementedPlatformServer()
}

// UnimplementedPlatformServer must be embedded to have forward compatible implementations.
type UnimplementedPlatformServer struct {
}

func (UnimplementedPlatformServer) IsAuthenticator(context.Context, *emptypb.Empty) (*ImplementsResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsAuthenticator not implemented")
}
func (UnimplementedPlatformServer) Auth(context.Context, *FuncSpec_Args) (*Auth_AuthResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Auth not implemented")
}
func (UnimplementedPlatformServer) AuthSpec(context.Context, *emptypb.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AuthSpec not implemented")
}
func (UnimplementedPlatformServer) ValidateAuth(context.Context, *FuncSpec_Args) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ValidateAuth not implemented")
}
func (UnimplementedPlatformServer) ValidateAuthSpec(context.Context, *emptypb.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ValidateAuthSpec not implemented")
}
func (UnimplementedPlatformServer) ConfigStruct(context.Context, *emptypb.Empty) (*Config_StructResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfigStruct not implemented")
}
func (UnimplementedPlatformServer) Configure(context.Context, *Config_ConfigureRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Configure not implemented")
}
func (UnimplementedPlatformServer) Documentation(context.Context, *emptypb.Empty) (*Config_Documentation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Documentation not implemented")
}
func (UnimplementedPlatformServer) DeploySpec(context.Context, *emptypb.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeploySpec not implemented")
}
func (UnimplementedPlatformServer) Deploy(context.Context, *FuncSpec_Args) (*Deploy_Resp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Deploy not implemented")
}
func (UnimplementedPlatformServer) DefaultReleaserSpec(context.Context, *emptypb.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DefaultReleaserSpec not implemented")
}
func (UnimplementedPlatformServer) DefaultReleaser(context.Context, *FuncSpec_Args) (*DefaultReleaser_Resp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DefaultReleaser not implemented")
}
func (UnimplementedPlatformServer) IsDestroyer(context.Context, *emptypb.Empty) (*ImplementsResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsDestroyer not implemented")
}
func (UnimplementedPlatformServer) DestroySpec(context.Context, *emptypb.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DestroySpec not implemented")
}
func (UnimplementedPlatformServer) Destroy(context.Context, *FuncSpec_Args) (*Destroy_Resp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Destroy not implemented")
}
func (UnimplementedPlatformServer) IsWorkspaceDestroyer(context.Context, *emptypb.Empty) (*ImplementsResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsWorkspaceDestroyer not implemented")
}
func (UnimplementedPlatformServer) DestroyWorkspaceSpec(context.Context, *emptypb.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DestroyWorkspaceSpec not implemented")
}
func (UnimplementedPlatformServer) DestroyWorkspace(context.Context, *FuncSpec_Args) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DestroyWorkspace not implemented")
}
func (UnimplementedPlatformServer) IsExecer(context.Context, *emptypb.Empty) (*ImplementsResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsExecer not implemented")
}
func (UnimplementedPlatformServer) ExecSpec(context.Context, *emptypb.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ExecSpec not implemented")
}
func (UnimplementedPlatformServer) Exec(context.Context, *FuncSpec_Args) (*ExecResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Exec not implemented")
}
func (UnimplementedPlatformServer) IsLogPlatform(context.Context, *emptypb.Empty) (*ImplementsResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsLogPlatform not implemented")
}
func (UnimplementedPlatformServer) LogsSpec(context.Context, *emptypb.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LogsSpec not implemented")
}
func (UnimplementedPlatformServer) Logs(context.Context, *FuncSpec_Args) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Logs not implemented")
}
func (UnimplementedPlatformServer) IsGeneration(context.Context, *emptypb.Empty) (*ImplementsResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsGeneration not implemented")
}
func (UnimplementedPlatformServer) GenerationSpec(context.Context, *emptypb.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GenerationSpec not implemented")
}
func (UnimplementedPlatformServer) Generation(context.Context, *FuncSpec_Args) (*Generation_Resp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Generation not implemented")
}
func (UnimplementedPlatformServer) IsStatus(context.Context, *emptypb.Empty) (*ImplementsResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsStatus not implemented")
}
func (UnimplementedPlatformServer) StatusSpec(context.Context, *emptypb.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StatusSpec not implemented")
}
func (UnimplementedPlatformServer) Status(context.Context, *FuncSpec_Args) (*StatusReport, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Status not implemented")
}
func (UnimplementedPlatformServer) mustEmbedUnimplementedPlatformServer() {}

// UnsafePlatformServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PlatformServer will
// result in compilation errors.
type UnsafePlatformServer interface {
	mustEmbedUnimplementedPlatformServer()
}

func RegisterPlatformServer(s grpc.ServiceRegistrar, srv PlatformServer) {
	s.RegisterService(&Platform_ServiceDesc, srv)
}

func _Platform_IsAuthenticator_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlatformServer).IsAuthenticator(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.waypoint.sdk.Platform/IsAuthenticator",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlatformServer).IsAuthenticator(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Platform_Auth_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlatformServer).Auth(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.waypoint.sdk.Platform/Auth",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlatformServer).Auth(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

func _Platform_AuthSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlatformServer).AuthSpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.waypoint.sdk.Platform/AuthSpec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlatformServer).AuthSpec(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Platform_ValidateAuth_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlatformServer).ValidateAuth(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.waypoint.sdk.Platform/ValidateAuth",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlatformServer).ValidateAuth(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

func _Platform_ValidateAuthSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlatformServer).ValidateAuthSpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.waypoint.sdk.Platform/ValidateAuthSpec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlatformServer).ValidateAuthSpec(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Platform_ConfigStruct_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlatformServer).ConfigStruct(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.waypoint.sdk.Platform/ConfigStruct",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlatformServer).ConfigStruct(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Platform_Configure_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Config_ConfigureRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlatformServer).Configure(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.waypoint.sdk.Platform/Configure",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlatformServer).Configure(ctx, req.(*Config_ConfigureRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Platform_Documentation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlatformServer).Documentation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.waypoint.sdk.Platform/Documentation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlatformServer).Documentation(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Platform_DeploySpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlatformServer).DeploySpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.waypoint.sdk.Platform/DeploySpec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlatformServer).DeploySpec(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Platform_Deploy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlatformServer).Deploy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.waypoint.sdk.Platform/Deploy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlatformServer).Deploy(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

func _Platform_DefaultReleaserSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlatformServer).DefaultReleaserSpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.waypoint.sdk.Platform/DefaultReleaserSpec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlatformServer).DefaultReleaserSpec(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Platform_DefaultReleaser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlatformServer).DefaultReleaser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.waypoint.sdk.Platform/DefaultReleaser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlatformServer).DefaultReleaser(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

func _Platform_IsDestroyer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlatformServer).IsDestroyer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.waypoint.sdk.Platform/IsDestroyer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlatformServer).IsDestroyer(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Platform_DestroySpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlatformServer).DestroySpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.waypoint.sdk.Platform/DestroySpec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlatformServer).DestroySpec(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Platform_Destroy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlatformServer).Destroy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.waypoint.sdk.Platform/Destroy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlatformServer).Destroy(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

func _Platform_IsWorkspaceDestroyer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlatformServer).IsWorkspaceDestroyer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.waypoint.sdk.Platform/IsWorkspaceDestroyer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlatformServer).IsWorkspaceDestroyer(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Platform_DestroyWorkspaceSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlatformServer).DestroyWorkspaceSpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.waypoint.sdk.Platform/DestroyWorkspaceSpec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlatformServer).DestroyWorkspaceSpec(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Platform_DestroyWorkspace_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlatformServer).DestroyWorkspace(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.waypoint.sdk.Platform/DestroyWorkspace",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlatformServer).DestroyWorkspace(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

func _Platform_IsExecer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlatformServer).IsExecer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.waypoint.sdk.Platform/IsExecer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlatformServer).IsExecer(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Platform_ExecSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlatformServer).ExecSpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.waypoint.sdk.Platform/ExecSpec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlatformServer).ExecSpec(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Platform_Exec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlatformServer).Exec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.waypoint.sdk.Platform/Exec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlatformServer).Exec(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

func _Platform_IsLogPlatform_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlatformServer).IsLogPlatform(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.waypoint.sdk.Platform/IsLogPlatform",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlatformServer).IsLogPlatform(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Platform_LogsSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlatformServer).LogsSpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.waypoint.sdk.Platform/LogsSpec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlatformServer).LogsSpec(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Platform_Logs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlatformServer).Logs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.waypoint.sdk.Platform/Logs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlatformServer).Logs(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

func _Platform_IsGeneration_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlatformServer).IsGeneration(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.waypoint.sdk.Platform/IsGeneration",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlatformServer).IsGeneration(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Platform_GenerationSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlatformServer).GenerationSpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.waypoint.sdk.Platform/GenerationSpec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlatformServer).GenerationSpec(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Platform_Generation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlatformServer).Generation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.waypoint.sdk.Platform/Generation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlatformServer).Generation(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

func _Platform_IsStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlatformServer).IsStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.waypoint.sdk.Platform/IsStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlatformServer).IsStatus(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Platform_StatusSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlatformServer).StatusSpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.waypoint.sdk.Platform/StatusSpec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlatformServer).StatusSpec(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Platform_Status_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlatformServer).Status(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.waypoint.sdk.Platform/Status",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlatformServer).Status(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

// Platform_ServiceDesc is the grpc.ServiceDesc for Platform service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Platform_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "hashicorp.waypoint.sdk.Platform",
	HandlerType: (*PlatformServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "IsAuthenticator",
			Handler:    _Platform_IsAuthenticator_Handler,
		},
		{
			MethodName: "Auth",
			Handler:    _Platform_Auth_Handler,
		},
		{
			MethodName: "AuthSpec",
			Handler:    _Platform_AuthSpec_Handler,
		},
		{
			MethodName: "ValidateAuth",
			Handler:    _Platform_ValidateAuth_Handler,
		},
		{
			MethodName: "ValidateAuthSpec",
			Handler:    _Platform_ValidateAuthSpec_Handler,
		},
		{
			MethodName: "ConfigStruct",
			Handler:    _Platform_ConfigStruct_Handler,
		},
		{
			MethodName: "Configure",
			Handler:    _Platform_Configure_Handler,
		},
		{
			MethodName: "Documentation",
			Handler:    _Platform_Documentation_Handler,
		},
		{
			MethodName: "DeploySpec",
			Handler:    _Platform_DeploySpec_Handler,
		},
		{
			MethodName: "Deploy",
			Handler:    _Platform_Deploy_Handler,
		},
		{
			MethodName: "DefaultReleaserSpec",
			Handler:    _Platform_DefaultReleaserSpec_Handler,
		},
		{
			MethodName: "DefaultReleaser",
			Handler:    _Platform_DefaultReleaser_Handler,
		},
		{
			MethodName: "IsDestroyer",
			Handler:    _Platform_IsDestroyer_Handler,
		},
		{
			MethodName: "DestroySpec",
			Handler:    _Platform_DestroySpec_Handler,
		},
		{
			MethodName: "Destroy",
			Handler:    _Platform_Destroy_Handler,
		},
		{
			MethodName: "IsWorkspaceDestroyer",
			Handler:    _Platform_IsWorkspaceDestroyer_Handler,
		},
		{
			MethodName: "DestroyWorkspaceSpec",
			Handler:    _Platform_DestroyWorkspaceSpec_Handler,
		},
		{
			MethodName: "DestroyWorkspace",
			Handler:    _Platform_DestroyWorkspace_Handler,
		},
		{
			MethodName: "IsExecer",
			Handler:    _Platform_IsExecer_Handler,
		},
		{
			MethodName: "ExecSpec",
			Handler:    _Platform_ExecSpec_Handler,
		},
		{
			MethodName: "Exec",
			Handler:    _Platform_Exec_Handler,
		},
		{
			MethodName: "IsLogPlatform",
			Handler:    _Platform_IsLogPlatform_Handler,
		},
		{
			MethodName: "LogsSpec",
			Handler:    _Platform_LogsSpec_Handler,
		},
		{
			MethodName: "Logs",
			Handler:    _Platform_Logs_Handler,
		},
		{
			MethodName: "IsGeneration",
			Handler:    _Platform_IsGeneration_Handler,
		},
		{
			MethodName: "GenerationSpec",
			Handler:    _Platform_GenerationSpec_Handler,
		},
		{
			MethodName: "Generation",
			Handler:    _Platform_Generation_Handler,
		},
		{
			MethodName: "IsStatus",
			Handler:    _Platform_IsStatus_Handler,
		},
		{
			MethodName: "StatusSpec",
			Handler:    _Platform_StatusSpec_Handler,
		},
		{
			MethodName: "Status",
			Handler:    _Platform_Status_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "plugin.proto",
}

// RegistryClient is the client API for Registry service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RegistryClient interface {
	IsAuthenticator(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ImplementsResp, error)
	Auth(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Auth_AuthResponse, error)
	AuthSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	ValidateAuth(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*emptypb.Empty, error)
	ValidateAuthSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	ConfigStruct(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Config_StructResp, error)
	Configure(ctx context.Context, in *Config_ConfigureRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Documentation(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Config_Documentation, error)
	PushSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	Push(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Push_Resp, error)
	// Access and AccessSpec are used to provide the optional component.RegistryAccess
	// interface.
	AccessSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	Access(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Access_Resp, error)
}

type registryClient struct {
	cc grpc.ClientConnInterface
}

func NewRegistryClient(cc grpc.ClientConnInterface) RegistryClient {
	return &registryClient{cc}
}

func (c *registryClient) IsAuthenticator(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ImplementsResp, error) {
	out := new(ImplementsResp)
	err := c.cc.Invoke(ctx, "/hashicorp.waypoint.sdk.Registry/IsAuthenticator", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *registryClient) Auth(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Auth_AuthResponse, error) {
	out := new(Auth_AuthResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.waypoint.sdk.Registry/Auth", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *registryClient) AuthSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, "/hashicorp.waypoint.sdk.Registry/AuthSpec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *registryClient) ValidateAuth(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/hashicorp.waypoint.sdk.Registry/ValidateAuth", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *registryClient) ValidateAuthSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, "/hashicorp.waypoint.sdk.Registry/ValidateAuthSpec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *registryClient) ConfigStruct(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Config_StructResp, error) {
	out := new(Config_StructResp)
	err := c.cc.Invoke(ctx, "/hashicorp.waypoint.sdk.Registry/ConfigStruct", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *registryClient) Configure(ctx context.Context, in *Config_ConfigureRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/hashicorp.waypoint.sdk.Registry/Configure", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *registryClient) Documentation(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Config_Documentation, error) {
	out := new(Config_Documentation)
	err := c.cc.Invoke(ctx, "/hashicorp.waypoint.sdk.Registry/Documentation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *registryClient) PushSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, "/hashicorp.waypoint.sdk.Registry/PushSpec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *registryClient) Push(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Push_Resp, error) {
	out := new(Push_Resp)
	err := c.cc.Invoke(ctx, "/hashicorp.waypoint.sdk.Registry/Push", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *registryClient) AccessSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, "/hashicorp.waypoint.sdk.Registry/AccessSpec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *registryClient) Access(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Access_Resp, error) {
	out := new(Access_Resp)
	err := c.cc.Invoke(ctx, "/hashicorp.waypoint.sdk.Registry/Access", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RegistryServer is the server API for Registry service.
// All implementations must embed UnimplementedRegistryServer
// for forward compatibility
type RegistryServer interface {
	IsAuthenticator(context.Context, *emptypb.Empty) (*ImplementsResp, error)
	Auth(context.Context, *FuncSpec_Args) (*Auth_AuthResponse, error)
	AuthSpec(context.Context, *emptypb.Empty) (*FuncSpec, error)
	ValidateAuth(context.Context, *FuncSpec_Args) (*emptypb.Empty, error)
	ValidateAuthSpec(context.Context, *emptypb.Empty) (*FuncSpec, error)
	ConfigStruct(context.Context, *emptypb.Empty) (*Config_StructResp, error)
	Configure(context.Context, *Config_ConfigureRequest) (*emptypb.Empty, error)
	Documentation(context.Context, *emptypb.Empty) (*Config_Documentation, error)
	PushSpec(context.Context, *emptypb.Empty) (*FuncSpec, error)
	Push(context.Context, *FuncSpec_Args) (*Push_Resp, error)
	// Access and AccessSpec are used to provide the optional component.RegistryAccess
	// interface.
	AccessSpec(context.Context, *emptypb.Empty) (*FuncSpec, error)
	Access(context.Context, *FuncSpec_Args) (*Access_Resp, error)
	mustEmbedUnimplementedRegistryServer()
}

// UnimplementedRegistryServer must be embedded to have forward compatible implementations.
type UnimplementedRegistryServer struct {
}

func (UnimplementedRegistryServer) IsAuthenticator(context.Context, *emptypb.Empty) (*ImplementsResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsAuthenticator not implemented")
}
func (UnimplementedRegistryServer) Auth(context.Context, *FuncSpec_Args) (*Auth_AuthResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Auth not implemented")
}
func (UnimplementedRegistryServer) AuthSpec(context.Context, *emptypb.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AuthSpec not implemented")
}
func (UnimplementedRegistryServer) ValidateAuth(context.Context, *FuncSpec_Args) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ValidateAuth not implemented")
}
func (UnimplementedRegistryServer) ValidateAuthSpec(context.Context, *emptypb.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ValidateAuthSpec not implemented")
}
func (UnimplementedRegistryServer) ConfigStruct(context.Context, *emptypb.Empty) (*Config_StructResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfigStruct not implemented")
}
func (UnimplementedRegistryServer) Configure(context.Context, *Config_ConfigureRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Configure not implemented")
}
func (UnimplementedRegistryServer) Documentation(context.Context, *emptypb.Empty) (*Config_Documentation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Documentation not implemented")
}
func (UnimplementedRegistryServer) PushSpec(context.Context, *emptypb.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PushSpec not implemented")
}
func (UnimplementedRegistryServer) Push(context.Context, *FuncSpec_Args) (*Push_Resp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Push not implemented")
}
func (UnimplementedRegistryServer) AccessSpec(context.Context, *emptypb.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AccessSpec not implemented")
}
func (UnimplementedRegistryServer) Access(context.Context, *FuncSpec_Args) (*Access_Resp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Access not implemented")
}
func (UnimplementedRegistryServer) mustEmbedUnimplementedRegistryServer() {}

// UnsafeRegistryServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RegistryServer will
// result in compilation errors.
type UnsafeRegistryServer interface {
	mustEmbedUnimplementedRegistryServer()
}

func RegisterRegistryServer(s grpc.ServiceRegistrar, srv RegistryServer) {
	s.RegisterService(&Registry_ServiceDesc, srv)
}

func _Registry_IsAuthenticator_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegistryServer).IsAuthenticator(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.waypoint.sdk.Registry/IsAuthenticator",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegistryServer).IsAuthenticator(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Registry_Auth_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegistryServer).Auth(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.waypoint.sdk.Registry/Auth",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegistryServer).Auth(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

func _Registry_AuthSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegistryServer).AuthSpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.waypoint.sdk.Registry/AuthSpec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegistryServer).AuthSpec(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Registry_ValidateAuth_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegistryServer).ValidateAuth(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.waypoint.sdk.Registry/ValidateAuth",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegistryServer).ValidateAuth(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

func _Registry_ValidateAuthSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegistryServer).ValidateAuthSpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.waypoint.sdk.Registry/ValidateAuthSpec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegistryServer).ValidateAuthSpec(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Registry_ConfigStruct_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegistryServer).ConfigStruct(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.waypoint.sdk.Registry/ConfigStruct",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegistryServer).ConfigStruct(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Registry_Configure_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Config_ConfigureRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegistryServer).Configure(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.waypoint.sdk.Registry/Configure",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegistryServer).Configure(ctx, req.(*Config_ConfigureRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Registry_Documentation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegistryServer).Documentation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.waypoint.sdk.Registry/Documentation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegistryServer).Documentation(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Registry_PushSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegistryServer).PushSpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.waypoint.sdk.Registry/PushSpec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegistryServer).PushSpec(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Registry_Push_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegistryServer).Push(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.waypoint.sdk.Registry/Push",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegistryServer).Push(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

func _Registry_AccessSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegistryServer).AccessSpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.waypoint.sdk.Registry/AccessSpec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegistryServer).AccessSpec(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Registry_Access_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegistryServer).Access(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.waypoint.sdk.Registry/Access",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegistryServer).Access(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

// Registry_ServiceDesc is the grpc.ServiceDesc for Registry service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Registry_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "hashicorp.waypoint.sdk.Registry",
	HandlerType: (*RegistryServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "IsAuthenticator",
			Handler:    _Registry_IsAuthenticator_Handler,
		},
		{
			MethodName: "Auth",
			Handler:    _Registry_Auth_Handler,
		},
		{
			MethodName: "AuthSpec",
			Handler:    _Registry_AuthSpec_Handler,
		},
		{
			MethodName: "ValidateAuth",
			Handler:    _Registry_ValidateAuth_Handler,
		},
		{
			MethodName: "ValidateAuthSpec",
			Handler:    _Registry_ValidateAuthSpec_Handler,
		},
		{
			MethodName: "ConfigStruct",
			Handler:    _Registry_ConfigStruct_Handler,
		},
		{
			MethodName: "Configure",
			Handler:    _Registry_Configure_Handler,
		},
		{
			MethodName: "Documentation",
			Handler:    _Registry_Documentation_Handler,
		},
		{
			MethodName: "PushSpec",
			Handler:    _Registry_PushSpec_Handler,
		},
		{
			MethodName: "Push",
			Handler:    _Registry_Push_Handler,
		},
		{
			MethodName: "AccessSpec",
			Handler:    _Registry_AccessSpec_Handler,
		},
		{
			MethodName: "Access",
			Handler:    _Registry_Access_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "plugin.proto",
}

// ReleaseManagerClient is the client API for ReleaseManager service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ReleaseManagerClient interface {
	IsAuthenticator(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ImplementsResp, error)
	Auth(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Auth_AuthResponse, error)
	AuthSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	ValidateAuth(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*emptypb.Empty, error)
	ValidateAuthSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	ConfigStruct(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Config_StructResp, error)
	Configure(ctx context.Context, in *Config_ConfigureRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Documentation(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Config_Documentation, error)
	// component.Destroyer optional implementation
	IsDestroyer(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ImplementsResp, error)
	DestroySpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	Destroy(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Destroy_Resp, error)
	// component.WorkspaceDestroyer optional implementation
	IsWorkspaceDestroyer(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ImplementsResp, error)
	DestroyWorkspaceSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	DestroyWorkspace(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*emptypb.Empty, error)
	ReleaseSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	Release(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Release_Resp, error)
	// component.Status optional implementation
	IsStatus(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ImplementsResp, error)
	StatusSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	Status(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*StatusReport, error)
}

type releaseManagerClient struct {
	cc grpc.ClientConnInterface
}

func NewReleaseManagerClient(cc grpc.ClientConnInterface) ReleaseManagerClient {
	return &releaseManagerClient{cc}
}

func (c *releaseManagerClient) IsAuthenticator(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ImplementsResp, error) {
	out := new(ImplementsResp)
	err := c.cc.Invoke(ctx, "/hashicorp.waypoint.sdk.ReleaseManager/IsAuthenticator", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *releaseManagerClient) Auth(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Auth_AuthResponse, error) {
	out := new(Auth_AuthResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.waypoint.sdk.ReleaseManager/Auth", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *releaseManagerClient) AuthSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, "/hashicorp.waypoint.sdk.ReleaseManager/AuthSpec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *releaseManagerClient) ValidateAuth(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/hashicorp.waypoint.sdk.ReleaseManager/ValidateAuth", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *releaseManagerClient) ValidateAuthSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, "/hashicorp.waypoint.sdk.ReleaseManager/ValidateAuthSpec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *releaseManagerClient) ConfigStruct(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Config_StructResp, error) {
	out := new(Config_StructResp)
	err := c.cc.Invoke(ctx, "/hashicorp.waypoint.sdk.ReleaseManager/ConfigStruct", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *releaseManagerClient) Configure(ctx context.Context, in *Config_ConfigureRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/hashicorp.waypoint.sdk.ReleaseManager/Configure", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *releaseManagerClient) Documentation(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Config_Documentation, error) {
	out := new(Config_Documentation)
	err := c.cc.Invoke(ctx, "/hashicorp.waypoint.sdk.ReleaseManager/Documentation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *releaseManagerClient) IsDestroyer(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ImplementsResp, error) {
	out := new(ImplementsResp)
	err := c.cc.Invoke(ctx, "/hashicorp.waypoint.sdk.ReleaseManager/IsDestroyer", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *releaseManagerClient) DestroySpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, "/hashicorp.waypoint.sdk.ReleaseManager/DestroySpec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *releaseManagerClient) Destroy(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Destroy_Resp, error) {
	out := new(Destroy_Resp)
	err := c.cc.Invoke(ctx, "/hashicorp.waypoint.sdk.ReleaseManager/Destroy", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *releaseManagerClient) IsWorkspaceDestroyer(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ImplementsResp, error) {
	out := new(ImplementsResp)
	err := c.cc.Invoke(ctx, "/hashicorp.waypoint.sdk.ReleaseManager/IsWorkspaceDestroyer", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *releaseManagerClient) DestroyWorkspaceSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, "/hashicorp.waypoint.sdk.ReleaseManager/DestroyWorkspaceSpec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *releaseManagerClient) DestroyWorkspace(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/hashicorp.waypoint.sdk.ReleaseManager/DestroyWorkspace", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *releaseManagerClient) ReleaseSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, "/hashicorp.waypoint.sdk.ReleaseManager/ReleaseSpec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *releaseManagerClient) Release(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Release_Resp, error) {
	out := new(Release_Resp)
	err := c.cc.Invoke(ctx, "/hashicorp.waypoint.sdk.ReleaseManager/Release", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *releaseManagerClient) IsStatus(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ImplementsResp, error) {
	out := new(ImplementsResp)
	err := c.cc.Invoke(ctx, "/hashicorp.waypoint.sdk.ReleaseManager/IsStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *releaseManagerClient) StatusSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, "/hashicorp.waypoint.sdk.ReleaseManager/StatusSpec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *releaseManagerClient) Status(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*StatusReport, error) {
	out := new(StatusReport)
	err := c.cc.Invoke(ctx, "/hashicorp.waypoint.sdk.ReleaseManager/Status", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ReleaseManagerServer is the server API for ReleaseManager service.
// All implementations must embed UnimplementedReleaseManagerServer
// for forward compatibility
type ReleaseManagerServer interface {
	IsAuthenticator(context.Context, *emptypb.Empty) (*ImplementsResp, error)
	Auth(context.Context, *FuncSpec_Args) (*Auth_AuthResponse, error)
	AuthSpec(context.Context, *emptypb.Empty) (*FuncSpec, error)
	ValidateAuth(context.Context, *FuncSpec_Args) (*emptypb.Empty, error)
	ValidateAuthSpec(context.Context, *emptypb.Empty) (*FuncSpec, error)
	ConfigStruct(context.Context, *emptypb.Empty) (*Config_StructResp, error)
	Configure(context.Context, *Config_ConfigureRequest) (*emptypb.Empty, error)
	Documentation(context.Context, *emptypb.Empty) (*Config_Documentation, error)
	// component.Destroyer optional implementation
	IsDestroyer(context.Context, *emptypb.Empty) (*ImplementsResp, error)
	DestroySpec(context.Context, *emptypb.Empty) (*FuncSpec, error)
	Destroy(context.Context, *FuncSpec_Args) (*Destroy_Resp, error)
	// component.WorkspaceDestroyer optional implementation
	IsWorkspaceDestroyer(context.Context, *emptypb.Empty) (*ImplementsResp, error)
	DestroyWorkspaceSpec(context.Context, *emptypb.Empty) (*FuncSpec, error)
	DestroyWorkspace(context.Context, *FuncSpec_Args) (*emptypb.Empty, error)
	ReleaseSpec(context.Context, *emptypb.Empty) (*FuncSpec, error)
	Release(context.Context, *FuncSpec_Args) (*Release_Resp, error)
	// component.Status optional implementation
	IsStatus(context.Context, *emptypb.Empty) (*ImplementsResp, error)
	StatusSpec(context.Context, *emptypb.Empty) (*FuncSpec, error)
	Status(context.Context, *FuncSpec_Args) (*StatusReport, error)
	mustEmbedUnimplementedReleaseManagerServer()
}

// UnimplementedReleaseManagerServer must be embedded to have forward compatible implementations.
type UnimplementedReleaseManagerServer struct {
}

func (UnimplementedReleaseManagerServer) IsAuthenticator(context.Context, *emptypb.Empty) (*ImplementsResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsAuthenticator not implemented")
}
func (UnimplementedReleaseManagerServer) Auth(context.Context, *FuncSpec_Args) (*Auth_AuthResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Auth not implemented")
}
func (UnimplementedReleaseManagerServer) AuthSpec(context.Context, *emptypb.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AuthSpec not implemented")
}
func (UnimplementedReleaseManagerServer) ValidateAuth(context.Context, *FuncSpec_Args) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ValidateAuth not implemented")
}
func (UnimplementedReleaseManagerServer) ValidateAuthSpec(context.Context, *emptypb.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ValidateAuthSpec not implemented")
}
func (UnimplementedReleaseManagerServer) ConfigStruct(context.Context, *emptypb.Empty) (*Config_StructResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfigStruct not implemented")
}
func (UnimplementedReleaseManagerServer) Configure(context.Context, *Config_ConfigureRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Configure not implemented")
}
func (UnimplementedReleaseManagerServer) Documentation(context.Context, *emptypb.Empty) (*Config_Documentation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Documentation not implemented")
}
func (UnimplementedReleaseManagerServer) IsDestroyer(context.Context, *emptypb.Empty) (*ImplementsResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsDestroyer not implemented")
}
func (UnimplementedReleaseManagerServer) DestroySpec(context.Context, *emptypb.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DestroySpec not implemented")
}
func (UnimplementedReleaseManagerServer) Destroy(context.Context, *FuncSpec_Args) (*Destroy_Resp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Destroy not implemented")
}
func (UnimplementedReleaseManagerServer) IsWorkspaceDestroyer(context.Context, *emptypb.Empty) (*ImplementsResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsWorkspaceDestroyer not implemented")
}
func (UnimplementedReleaseManagerServer) DestroyWorkspaceSpec(context.Context, *emptypb.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DestroyWorkspaceSpec not implemented")
}
func (UnimplementedReleaseManagerServer) DestroyWorkspace(context.Context, *FuncSpec_Args) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DestroyWorkspace not implemented")
}
func (UnimplementedReleaseManagerServer) ReleaseSpec(context.Context, *emptypb.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReleaseSpec not implemented")
}
func (UnimplementedReleaseManagerServer) Release(context.Context, *FuncSpec_Args) (*Release_Resp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Release not implemented")
}
func (UnimplementedReleaseManagerServer) IsStatus(context.Context, *emptypb.Empty) (*ImplementsResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsStatus not implemented")
}
func (UnimplementedReleaseManagerServer) StatusSpec(context.Context, *emptypb.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StatusSpec not implemented")
}
func (UnimplementedReleaseManagerServer) Status(context.Context, *FuncSpec_Args) (*StatusReport, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Status not implemented")
}
func (UnimplementedReleaseManagerServer) mustEmbedUnimplementedReleaseManagerServer() {}

// UnsafeReleaseManagerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ReleaseManagerServer will
// result in compilation errors.
type UnsafeReleaseManagerServer interface {
	mustEmbedUnimplementedReleaseManagerServer()
}

func RegisterReleaseManagerServer(s grpc.ServiceRegistrar, srv ReleaseManagerServer) {
	s.RegisterService(&ReleaseManager_ServiceDesc, srv)
}

func _ReleaseManager_IsAuthenticator_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReleaseManagerServer).IsAuthenticator(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.waypoint.sdk.ReleaseManager/IsAuthenticator",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReleaseManagerServer).IsAuthenticator(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReleaseManager_Auth_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReleaseManagerServer).Auth(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.waypoint.sdk.ReleaseManager/Auth",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReleaseManagerServer).Auth(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReleaseManager_AuthSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReleaseManagerServer).AuthSpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.waypoint.sdk.ReleaseManager/AuthSpec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReleaseManagerServer).AuthSpec(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReleaseManager_ValidateAuth_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReleaseManagerServer).ValidateAuth(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.waypoint.sdk.ReleaseManager/ValidateAuth",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReleaseManagerServer).ValidateAuth(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReleaseManager_ValidateAuthSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReleaseManagerServer).ValidateAuthSpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.waypoint.sdk.ReleaseManager/ValidateAuthSpec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReleaseManagerServer).ValidateAuthSpec(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReleaseManager_ConfigStruct_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReleaseManagerServer).ConfigStruct(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.waypoint.sdk.ReleaseManager/ConfigStruct",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReleaseManagerServer).ConfigStruct(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReleaseManager_Configure_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Config_ConfigureRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReleaseManagerServer).Configure(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.waypoint.sdk.ReleaseManager/Configure",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReleaseManagerServer).Configure(ctx, req.(*Config_ConfigureRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReleaseManager_Documentation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReleaseManagerServer).Documentation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.waypoint.sdk.ReleaseManager/Documentation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReleaseManagerServer).Documentation(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReleaseManager_IsDestroyer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReleaseManagerServer).IsDestroyer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.waypoint.sdk.ReleaseManager/IsDestroyer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReleaseManagerServer).IsDestroyer(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReleaseManager_DestroySpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReleaseManagerServer).DestroySpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.waypoint.sdk.ReleaseManager/DestroySpec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReleaseManagerServer).DestroySpec(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReleaseManager_Destroy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReleaseManagerServer).Destroy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.waypoint.sdk.ReleaseManager/Destroy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReleaseManagerServer).Destroy(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReleaseManager_IsWorkspaceDestroyer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReleaseManagerServer).IsWorkspaceDestroyer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.waypoint.sdk.ReleaseManager/IsWorkspaceDestroyer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReleaseManagerServer).IsWorkspaceDestroyer(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReleaseManager_DestroyWorkspaceSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReleaseManagerServer).DestroyWorkspaceSpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.waypoint.sdk.ReleaseManager/DestroyWorkspaceSpec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReleaseManagerServer).DestroyWorkspaceSpec(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReleaseManager_DestroyWorkspace_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReleaseManagerServer).DestroyWorkspace(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.waypoint.sdk.ReleaseManager/DestroyWorkspace",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReleaseManagerServer).DestroyWorkspace(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReleaseManager_ReleaseSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReleaseManagerServer).ReleaseSpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.waypoint.sdk.ReleaseManager/ReleaseSpec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReleaseManagerServer).ReleaseSpec(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReleaseManager_Release_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReleaseManagerServer).Release(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.waypoint.sdk.ReleaseManager/Release",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReleaseManagerServer).Release(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReleaseManager_IsStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReleaseManagerServer).IsStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.waypoint.sdk.ReleaseManager/IsStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReleaseManagerServer).IsStatus(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReleaseManager_StatusSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReleaseManagerServer).StatusSpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.waypoint.sdk.ReleaseManager/StatusSpec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReleaseManagerServer).StatusSpec(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReleaseManager_Status_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReleaseManagerServer).Status(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.waypoint.sdk.ReleaseManager/Status",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReleaseManagerServer).Status(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

// ReleaseManager_ServiceDesc is the grpc.ServiceDesc for ReleaseManager service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ReleaseManager_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "hashicorp.waypoint.sdk.ReleaseManager",
	HandlerType: (*ReleaseManagerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "IsAuthenticator",
			Handler:    _ReleaseManager_IsAuthenticator_Handler,
		},
		{
			MethodName: "Auth",
			Handler:    _ReleaseManager_Auth_Handler,
		},
		{
			MethodName: "AuthSpec",
			Handler:    _ReleaseManager_AuthSpec_Handler,
		},
		{
			MethodName: "ValidateAuth",
			Handler:    _ReleaseManager_ValidateAuth_Handler,
		},
		{
			MethodName: "ValidateAuthSpec",
			Handler:    _ReleaseManager_ValidateAuthSpec_Handler,
		},
		{
			MethodName: "ConfigStruct",
			Handler:    _ReleaseManager_ConfigStruct_Handler,
		},
		{
			MethodName: "Configure",
			Handler:    _ReleaseManager_Configure_Handler,
		},
		{
			MethodName: "Documentation",
			Handler:    _ReleaseManager_Documentation_Handler,
		},
		{
			MethodName: "IsDestroyer",
			Handler:    _ReleaseManager_IsDestroyer_Handler,
		},
		{
			MethodName: "DestroySpec",
			Handler:    _ReleaseManager_DestroySpec_Handler,
		},
		{
			MethodName: "Destroy",
			Handler:    _ReleaseManager_Destroy_Handler,
		},
		{
			MethodName: "IsWorkspaceDestroyer",
			Handler:    _ReleaseManager_IsWorkspaceDestroyer_Handler,
		},
		{
			MethodName: "DestroyWorkspaceSpec",
			Handler:    _ReleaseManager_DestroyWorkspaceSpec_Handler,
		},
		{
			MethodName: "DestroyWorkspace",
			Handler:    _ReleaseManager_DestroyWorkspace_Handler,
		},
		{
			MethodName: "ReleaseSpec",
			Handler:    _ReleaseManager_ReleaseSpec_Handler,
		},
		{
			MethodName: "Release",
			Handler:    _ReleaseManager_Release_Handler,
		},
		{
			MethodName: "IsStatus",
			Handler:    _ReleaseManager_IsStatus_Handler,
		},
		{
			MethodName: "StatusSpec",
			Handler:    _ReleaseManager_StatusSpec_Handler,
		},
		{
			MethodName: "Status",
			Handler:    _ReleaseManager_Status_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "plugin.proto",
}

// ConfigSourcerClient is the client API for ConfigSourcer service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ConfigSourcerClient interface {
	ConfigStruct(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Config_StructResp, error)
	Configure(ctx context.Context, in *Config_ConfigureRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Documentation(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Config_Documentation, error)
	ReadSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	Read(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*ConfigSource_ReadResponse, error)
	StopSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	Stop(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type configSourcerClient struct {
	cc grpc.ClientConnInterface
}

func NewConfigSourcerClient(cc grpc.ClientConnInterface) ConfigSourcerClient {
	return &configSourcerClient{cc}
}

func (c *configSourcerClient) ConfigStruct(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Config_StructResp, error) {
	out := new(Config_StructResp)
	err := c.cc.Invoke(ctx, "/hashicorp.waypoint.sdk.ConfigSourcer/ConfigStruct", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *configSourcerClient) Configure(ctx context.Context, in *Config_ConfigureRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/hashicorp.waypoint.sdk.ConfigSourcer/Configure", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *configSourcerClient) Documentation(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Config_Documentation, error) {
	out := new(Config_Documentation)
	err := c.cc.Invoke(ctx, "/hashicorp.waypoint.sdk.ConfigSourcer/Documentation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *configSourcerClient) ReadSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, "/hashicorp.waypoint.sdk.ConfigSourcer/ReadSpec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *configSourcerClient) Read(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*ConfigSource_ReadResponse, error) {
	out := new(ConfigSource_ReadResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.waypoint.sdk.ConfigSourcer/Read", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *configSourcerClient) StopSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, "/hashicorp.waypoint.sdk.ConfigSourcer/StopSpec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *configSourcerClient) Stop(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/hashicorp.waypoint.sdk.ConfigSourcer/Stop", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ConfigSourcerServer is the server API for ConfigSourcer service.
// All implementations must embed UnimplementedConfigSourcerServer
// for forward compatibility
type ConfigSourcerServer interface {
	ConfigStruct(context.Context, *emptypb.Empty) (*Config_StructResp, error)
	Configure(context.Context, *Config_ConfigureRequest) (*emptypb.Empty, error)
	Documentation(context.Context, *emptypb.Empty) (*Config_Documentation, error)
	ReadSpec(context.Context, *emptypb.Empty) (*FuncSpec, error)
	Read(context.Context, *FuncSpec_Args) (*ConfigSource_ReadResponse, error)
	StopSpec(context.Context, *emptypb.Empty) (*FuncSpec, error)
	Stop(context.Context, *FuncSpec_Args) (*emptypb.Empty, error)
	mustEmbedUnimplementedConfigSourcerServer()
}

// UnimplementedConfigSourcerServer must be embedded to have forward compatible implementations.
type UnimplementedConfigSourcerServer struct {
}

func (UnimplementedConfigSourcerServer) ConfigStruct(context.Context, *emptypb.Empty) (*Config_StructResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfigStruct not implemented")
}
func (UnimplementedConfigSourcerServer) Configure(context.Context, *Config_ConfigureRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Configure not implemented")
}
func (UnimplementedConfigSourcerServer) Documentation(context.Context, *emptypb.Empty) (*Config_Documentation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Documentation not implemented")
}
func (UnimplementedConfigSourcerServer) ReadSpec(context.Context, *emptypb.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReadSpec not implemented")
}
func (UnimplementedConfigSourcerServer) Read(context.Context, *FuncSpec_Args) (*ConfigSource_ReadResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Read not implemented")
}
func (UnimplementedConfigSourcerServer) StopSpec(context.Context, *emptypb.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StopSpec not implemented")
}
func (UnimplementedConfigSourcerServer) Stop(context.Context, *FuncSpec_Args) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Stop not implemented")
}
func (UnimplementedConfigSourcerServer) mustEmbedUnimplementedConfigSourcerServer() {}

// UnsafeConfigSourcerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ConfigSourcerServer will
// result in compilation errors.
type UnsafeConfigSourcerServer interface {
	mustEmbedUnimplementedConfigSourcerServer()
}

func RegisterConfigSourcerServer(s grpc.ServiceRegistrar, srv ConfigSourcerServer) {
	s.RegisterService(&ConfigSourcer_ServiceDesc, srv)
}

func _ConfigSourcer_ConfigStruct_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConfigSourcerServer).ConfigStruct(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.waypoint.sdk.ConfigSourcer/ConfigStruct",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConfigSourcerServer).ConfigStruct(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConfigSourcer_Configure_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Config_ConfigureRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConfigSourcerServer).Configure(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.waypoint.sdk.ConfigSourcer/Configure",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConfigSourcerServer).Configure(ctx, req.(*Config_ConfigureRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConfigSourcer_Documentation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConfigSourcerServer).Documentation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.waypoint.sdk.ConfigSourcer/Documentation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConfigSourcerServer).Documentation(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConfigSourcer_ReadSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConfigSourcerServer).ReadSpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.waypoint.sdk.ConfigSourcer/ReadSpec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConfigSourcerServer).ReadSpec(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConfigSourcer_Read_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConfigSourcerServer).Read(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.waypoint.sdk.ConfigSourcer/Read",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConfigSourcerServer).Read(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConfigSourcer_StopSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConfigSourcerServer).StopSpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.waypoint.sdk.ConfigSourcer/StopSpec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConfigSourcerServer).StopSpec(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConfigSourcer_Stop_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConfigSourcerServer).Stop(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.waypoint.sdk.ConfigSourcer/Stop",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConfigSourcerServer).Stop(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

// ConfigSourcer_ServiceDesc is the grpc.ServiceDesc for ConfigSourcer service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ConfigSourcer_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "hashicorp.waypoint.sdk.ConfigSourcer",
	HandlerType: (*ConfigSourcerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ConfigStruct",
			Handler:    _ConfigSourcer_ConfigStruct_Handler,
		},
		{
			MethodName: "Configure",
			Handler:    _ConfigSourcer_Configure_Handler,
		},
		{
			MethodName: "Documentation",
			Handler:    _ConfigSourcer_Documentation_Handler,
		},
		{
			MethodName: "ReadSpec",
			Handler:    _ConfigSourcer_ReadSpec_Handler,
		},
		{
			MethodName: "Read",
			Handler:    _ConfigSourcer_Read_Handler,
		},
		{
			MethodName: "StopSpec",
			Handler:    _ConfigSourcer_StopSpec_Handler,
		},
		{
			MethodName: "Stop",
			Handler:    _ConfigSourcer_Stop_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "plugin.proto",
}

// TaskLauncherClient is the client API for TaskLauncher service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TaskLauncherClient interface {
	ConfigStruct(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Config_StructResp, error)
	Configure(ctx context.Context, in *Config_ConfigureRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Documentation(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Config_Documentation, error)
	StartSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	StopSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	WatchSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	StartTask(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*TaskLaunch_Resp, error)
	StopTask(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*emptypb.Empty, error)
	WatchTask(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*TaskWatch_Resp, error)
}

type taskLauncherClient struct {
	cc grpc.ClientConnInterface
}

func NewTaskLauncherClient(cc grpc.ClientConnInterface) TaskLauncherClient {
	return &taskLauncherClient{cc}
}

func (c *taskLauncherClient) ConfigStruct(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Config_StructResp, error) {
	out := new(Config_StructResp)
	err := c.cc.Invoke(ctx, "/hashicorp.waypoint.sdk.TaskLauncher/ConfigStruct", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taskLauncherClient) Configure(ctx context.Context, in *Config_ConfigureRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/hashicorp.waypoint.sdk.TaskLauncher/Configure", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taskLauncherClient) Documentation(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Config_Documentation, error) {
	out := new(Config_Documentation)
	err := c.cc.Invoke(ctx, "/hashicorp.waypoint.sdk.TaskLauncher/Documentation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taskLauncherClient) StartSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, "/hashicorp.waypoint.sdk.TaskLauncher/StartSpec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taskLauncherClient) StopSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, "/hashicorp.waypoint.sdk.TaskLauncher/StopSpec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taskLauncherClient) WatchSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, "/hashicorp.waypoint.sdk.TaskLauncher/WatchSpec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taskLauncherClient) StartTask(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*TaskLaunch_Resp, error) {
	out := new(TaskLaunch_Resp)
	err := c.cc.Invoke(ctx, "/hashicorp.waypoint.sdk.TaskLauncher/StartTask", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taskLauncherClient) StopTask(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/hashicorp.waypoint.sdk.TaskLauncher/StopTask", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taskLauncherClient) WatchTask(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*TaskWatch_Resp, error) {
	out := new(TaskWatch_Resp)
	err := c.cc.Invoke(ctx, "/hashicorp.waypoint.sdk.TaskLauncher/WatchTask", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TaskLauncherServer is the server API for TaskLauncher service.
// All implementations must embed UnimplementedTaskLauncherServer
// for forward compatibility
type TaskLauncherServer interface {
	ConfigStruct(context.Context, *emptypb.Empty) (*Config_StructResp, error)
	Configure(context.Context, *Config_ConfigureRequest) (*emptypb.Empty, error)
	Documentation(context.Context, *emptypb.Empty) (*Config_Documentation, error)
	StartSpec(context.Context, *emptypb.Empty) (*FuncSpec, error)
	StopSpec(context.Context, *emptypb.Empty) (*FuncSpec, error)
	WatchSpec(context.Context, *emptypb.Empty) (*FuncSpec, error)
	StartTask(context.Context, *FuncSpec_Args) (*TaskLaunch_Resp, error)
	StopTask(context.Context, *FuncSpec_Args) (*emptypb.Empty, error)
	WatchTask(context.Context, *FuncSpec_Args) (*TaskWatch_Resp, error)
	mustEmbedUnimplementedTaskLauncherServer()
}

// UnimplementedTaskLauncherServer must be embedded to have forward compatible implementations.
type UnimplementedTaskLauncherServer struct {
}

func (UnimplementedTaskLauncherServer) ConfigStruct(context.Context, *emptypb.Empty) (*Config_StructResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfigStruct not implemented")
}
func (UnimplementedTaskLauncherServer) Configure(context.Context, *Config_ConfigureRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Configure not implemented")
}
func (UnimplementedTaskLauncherServer) Documentation(context.Context, *emptypb.Empty) (*Config_Documentation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Documentation not implemented")
}
func (UnimplementedTaskLauncherServer) StartSpec(context.Context, *emptypb.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartSpec not implemented")
}
func (UnimplementedTaskLauncherServer) StopSpec(context.Context, *emptypb.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StopSpec not implemented")
}
func (UnimplementedTaskLauncherServer) WatchSpec(context.Context, *emptypb.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WatchSpec not implemented")
}
func (UnimplementedTaskLauncherServer) StartTask(context.Context, *FuncSpec_Args) (*TaskLaunch_Resp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartTask not implemented")
}
func (UnimplementedTaskLauncherServer) StopTask(context.Context, *FuncSpec_Args) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StopTask not implemented")
}
func (UnimplementedTaskLauncherServer) WatchTask(context.Context, *FuncSpec_Args) (*TaskWatch_Resp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WatchTask not implemented")
}
func (UnimplementedTaskLauncherServer) mustEmbedUnimplementedTaskLauncherServer() {}

// UnsafeTaskLauncherServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TaskLauncherServer will
// result in compilation errors.
type UnsafeTaskLauncherServer interface {
	mustEmbedUnimplementedTaskLauncherServer()
}

func RegisterTaskLauncherServer(s grpc.ServiceRegistrar, srv TaskLauncherServer) {
	s.RegisterService(&TaskLauncher_ServiceDesc, srv)
}

func _TaskLauncher_ConfigStruct_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskLauncherServer).ConfigStruct(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.waypoint.sdk.TaskLauncher/ConfigStruct",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskLauncherServer).ConfigStruct(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _TaskLauncher_Configure_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Config_ConfigureRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskLauncherServer).Configure(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.waypoint.sdk.TaskLauncher/Configure",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskLauncherServer).Configure(ctx, req.(*Config_ConfigureRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TaskLauncher_Documentation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskLauncherServer).Documentation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.waypoint.sdk.TaskLauncher/Documentation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskLauncherServer).Documentation(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _TaskLauncher_StartSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskLauncherServer).StartSpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.waypoint.sdk.TaskLauncher/StartSpec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskLauncherServer).StartSpec(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _TaskLauncher_StopSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskLauncherServer).StopSpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.waypoint.sdk.TaskLauncher/StopSpec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskLauncherServer).StopSpec(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _TaskLauncher_WatchSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskLauncherServer).WatchSpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.waypoint.sdk.TaskLauncher/WatchSpec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskLauncherServer).WatchSpec(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _TaskLauncher_StartTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskLauncherServer).StartTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.waypoint.sdk.TaskLauncher/StartTask",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskLauncherServer).StartTask(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

func _TaskLauncher_StopTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskLauncherServer).StopTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.waypoint.sdk.TaskLauncher/StopTask",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskLauncherServer).StopTask(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

func _TaskLauncher_WatchTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskLauncherServer).WatchTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.waypoint.sdk.TaskLauncher/WatchTask",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskLauncherServer).WatchTask(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

// TaskLauncher_ServiceDesc is the grpc.ServiceDesc for TaskLauncher service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TaskLauncher_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "hashicorp.waypoint.sdk.TaskLauncher",
	HandlerType: (*TaskLauncherServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ConfigStruct",
			Handler:    _TaskLauncher_ConfigStruct_Handler,
		},
		{
			MethodName: "Configure",
			Handler:    _TaskLauncher_Configure_Handler,
		},
		{
			MethodName: "Documentation",
			Handler:    _TaskLauncher_Documentation_Handler,
		},
		{
			MethodName: "StartSpec",
			Handler:    _TaskLauncher_StartSpec_Handler,
		},
		{
			MethodName: "StopSpec",
			Handler:    _TaskLauncher_StopSpec_Handler,
		},
		{
			MethodName: "WatchSpec",
			Handler:    _TaskLauncher_WatchSpec_Handler,
		},
		{
			MethodName: "StartTask",
			Handler:    _TaskLauncher_StartTask_Handler,
		},
		{
			MethodName: "StopTask",
			Handler:    _TaskLauncher_StopTask_Handler,
		},
		{
			MethodName: "WatchTask",
			Handler:    _TaskLauncher_WatchTask_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "plugin.proto",
}
